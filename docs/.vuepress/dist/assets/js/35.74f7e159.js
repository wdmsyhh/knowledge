(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{332:function(_,v,e){"use strict";e.r(v);var a=e(14),l=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("title: PHP 基础\nspeaker: Zach Zhang")]),_._v(" "),v("slide"),_._v(" "),v("h1",{attrs:{id:"php-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#php-基础"}},[_._v("#")]),_._v(" PHP 基础")]),_._v(" "),v("p",[_._v("Zach Zhang")]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"主要内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要内容"}},[_._v("#")]),_._v(" 主要内容")]),_._v(" "),v("ul",[v("li",[_._v("PHP 语言特性")]),_._v(" "),v("li",[_._v("PHP 语言参考")])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"基本介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本介绍"}},[_._v("#")]),_._v(" 基本介绍")]),_._v(" "),v("ul",[v("li",[_._v("PHP 特性：\n"),v("ul",[v("li",[_._v("脚本语言，解释型。")]),_._v(" "),v("li",[_._v("弱类型。")]),_._v(" "),v("li",[_._v("面向对象。")])])]),_._v(" "),v("li",[_._v("PHP 标记：\n"),v("ul",[v("li",[v("code",[_._v("<?php")]),_._v(" 和 "),v("code",[_._v("?>")]),_._v("，纯 PHP 文件中省略结束标记，避免输出不期望的字符。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[_._v("#")]),_._v(" 类型")]),_._v(" "),v("p",[_._v("PHP 支持 9 种原始数据类型。")]),_._v(" "),v("ul",[v("li",[_._v("四种标量类型：\n"),v("ul",[v("li",[_._v("boolean（布尔型）")]),_._v(" "),v("li",[_._v("integer（整型）")]),_._v(" "),v("li",[_._v("float（浮点型，也称作 double)")]),_._v(" "),v("li",[_._v("string（字符串）")])])]),_._v(" "),v("li",[_._v("三种复合类型：\n"),v("ul",[v("li",[_._v("array（数组）")]),_._v(" "),v("li",[_._v("object（对象）")]),_._v(" "),v("li",[_._v("callable（可调用）")])])]),_._v(" "),v("li",[_._v("最后是两种特殊类型：\n"),v("ul",[v("li",[_._v("resource（资源）：保存了到外部资源的一个引用，资源是通过专门的函数来建立和使用的，"),v("a",{attrs:{href:"https://www.php.net/manual/zh/resource.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("所有这些函数及其相应资源类型"),v("OutboundLink")],1),_._v("。")]),_._v(" "),v("li",[_._v("NULL（无类型）")])])])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[_._v("#")]),_._v(" 数组")]),_._v(" "),v("ul",[v("li",[_._v("定义： "),v("code",[_._v("array()")]),_._v(" or "),v("code",[_._v("[]")]),_._v("。")]),_._v(" "),v("li",[_._v("key 可以是 integer 或者 string，value 可以是任意类型。")]),_._v(" "),v("li",[_._v("此外 key 会有如下的强制转换：\n"),v("ul",[v("li",[_._v('包含有合法整型值的字符串会被转换为整型。例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值。')]),_._v(" "),v("li",[_._v("浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。")]),_._v(" "),v("li",[_._v("布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。")]),_._v(" "),v("li",[_._v('Null 会被转换为空字符串，即键名 null 实际会被储存为 ""。')]),_._v(" "),v("li",[_._v("数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。")])])]),_._v(" "),v("li",[_._v("数组可以同时含有 integer 和 string 类型的键名，因为 PHP 实际并不区分"),v("strong",[_._v("索引数组")]),_._v("和"),v("strong",[_._v("关联数组")]),_._v("。\n"),v("ul",[v("li",[_._v("索引数组：没有指定 key 或这 key 为连续的整数，如："),v("code",[_._v("$arr = ['hello', '1' => 'world']")]),_._v("。")]),_._v(" "),v("li",[_._v("关联数组：有执行数组元素的 key，如："),v("code",[_._v("$arr = ['hello', '2' => 'world']")]),_._v("，与其他语言交互时，会被解析成对象，而非数组。")]),_._v(" "),v("li",[_._v("如果未指定 key，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。")])])]),_._v(" "),v("li",[_._v("遍历数组：\n"),v("ul",[v("li",[v("code",[_._v("foreach($arr as $value)")]),_._v(" 语法结构提供了遍历数组的简单方式，仅能够应用于数组和对象。")]),_._v(" "),v("li",[v("code",[_._v("foreach($arr as &$value)")]),_._v(" 可以很容易地通过在 $value 之前加上 "),v("code",[_._v("&")]),_._v(" 来修改数组的元素。")]),_._v(" "),v("li",[_._v("数组最后一个元素的 "),v("code",[_._v("$value")]),_._v(" 引用在 "),v("code",[_._v("foreach")]),_._v(" 循环之后仍会保留，后续如果有使用 "),v("code",[_._v("$value")]),_._v(" 变量会有影响，建议使用 "),v("code",[_._v("unset()")]),_._v(" 来将其销毁。")])])])]),_._v(" "),v("slide"),_._v(" "),v("ul",[v("li",[_._v("常用函数以及注意事项：\n"),v("ul",[v("li",[_._v("使用时一定注意该函数是否会重新索引，以及后续操作是否使用索引。")]),_._v(" "),v("li",[_._v("如果需要删除后重建索引，可以用 "),v("code",[_._v("array_values()")]),_._v(" 函数。")]),_._v(" "),v("li",[v("code",[_._v("unset()")]),_._v(" 函数允许删除数组中的某个键，但要注意数组将不会重建索引。")]),_._v(" "),v("li",[v("code",[_._v("array_diff($array1, $array2)")]),_._v(" 返回一个数组，该数组包括了所有在 array1 中但是不在任何其它参数数组中的值。注意键名保留不变。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"callback-callable-类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#callback-callable-类型"}},[_._v("#")]),_._v(" Callback/Callable 类型")]),_._v(" "),v("p",[_._v("一些函数如 "),v("code",[_._v("call_user_func()")]),_._v(" 或 "),v("code",[_._v("usort()")]),_._v(" 可以接受用户自定义的回调函数或"),v("strong",[_._v("匿名函数")]),_._v("作为参数，回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。")]),_._v(" "),v("ul",[v("li",[_._v("匿名函数：也叫闭包函数，允许临时创建一个没有指定名称的函数。\n"),v("ul",[v("li",[_._v("匿名函数对应内置类 "),v("a",{attrs:{href:"https://www.php.net/manual/zh/class.closure.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("Closure 的对象实例"),v("OutboundLink")],1),_._v("。")]),_._v(" "),v("li",[_._v("闭包可以从父作用域中继承变量，任何此类变量都应该用 use 语言结构传递进去。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"类型转换与比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类型转换与比较"}},[_._v("#")]),_._v(" 类型转换与比较")]),_._v(" "),v("ul",[v("li",[_._v("类型判断与转换：\n"),v("ul",[v("li",[_._v("通过 "),v("code",[_._v("var_dump()")]),_._v(" 函数，查看表达式的类型和值。")]),_._v(" "),v("li",[_._v("强制类型转换。"),v("code",[_._v("(string) 1")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("gettype()")]),_._v(" 和 "),v("code",[_._v("settype()")]),_._v("。")]),_._v(" "),v("li",[_._v("注意事项：\n"),v("ul",[v("li",[_._v("绝不要将未知的 "),v("code",[_._v("float")]),_._v(" 强制转换为 integer，这样有时会导致不可预料的结果。"),v("code",[_._v("(int) ((0.1+0.7) * 10); // 显示 7!")]),_._v("。")])])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/types.comparisons.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("类型比较"),v("OutboundLink")],1),_._v("：\n"),v("ul",[v("li",[_._v("空值判断："),v("code",[_._v("empty()")]),_._v("、"),v("code",[_._v("isset()")]),_._v("、"),v("code",[_._v("is_null()")]),_._v("。")]),_._v(" "),v("li",[_._v("松散("),v("code",[_._v("==")]),_._v(")比较与严格("),v("code",[_._v("===")]),_._v(")比较。")]),_._v(" "),v("li",[_._v("浮点数大小比较。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[_._v("#")]),_._v(" 变量")]),_._v(" "),v("ul",[v("li",[_._v("变量名不区分大小写。")]),_._v(" "),v("li",[_._v("使用："),v("code",[_._v("$var")]),_._v("、"),v("code",[_._v("${var}")]),_._v("。")]),_._v(" "),v("li",[_._v("变量默认值传递，只有使用 "),v("code",[_._v("&")]),_._v(" 时才会进行引用传递。")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/reserved.variables.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("预定义变量"),v("OutboundLink")],1),_._v("："),v("code",[_._v("$GLOBALS")]),_._v("、"),v("code",[_._v("$_SERVER")]),_._v("、"),v("code",[_._v("$_GET")]),_._v("...")]),_._v(" "),v("li",[_._v("变量范围：\n"),v("ul",[v("li",[_._v("全局变量：PHP 的全局变量和 C 语言有一点点不同，在 C 语言中，全局变量在函数中自动生效，除非被局部变量覆盖。这可能引起一些问题，有些人可能不小心就改变了一个全局变量。PHP 中全局变量在函数中使用时必须声明为 "),v("code",[_._v("global")]),_._v("。")]),_._v(" "),v("li",[_._v("静态变量："),v("code",[_._v("static")]),_._v("，脱离函数时静态变量值并不消失，只有在第一次调用时被赋值。")]),_._v(" "),v("li",[_._v("可变变量：一个可变变量获取了一个普通变量的值作为这个可变变量的变量名 "),v("code",[_._v("$$var")]),_._v(" or "),v("code",[_._v("${$var}")]),_._v("。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"常量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常量"}},[_._v("#")]),_._v(" 常量")]),_._v(" "),v("p",[_._v("常量默认为大小写敏感，"),v("strong",[_._v("常量标识符总是大写")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("定义 "),v("code",[_._v("define('GLOBAL_VAR', 'globalVar')")]),_._v("。")]),_._v(" "),v("li",[_._v("常量的作用域是全局的。")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/language.constants.predefined.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("魔术常量"),v("OutboundLink")],1),_._v("。")])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"表达式与运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表达式与运算符"}},[_._v("#")]),_._v(" 表达式与运算符")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/language.operators.precedence.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("运算符优先级与结合顺序"),v("OutboundLink")],1),_._v("。")]),_._v(" "),v("li",[_._v("类型比较：\n"),v("ul",[v("li",[v("code",[_._v("==")]),_._v(" 和 "),v("code",[_._v("===")]),_._v("，前面类型比较处有介绍。")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/language.operators.comparison.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("不同类型之间比较"),v("OutboundLink")],1)])])])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"流程控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程控制"}},[_._v("#")]),_._v(" 流程控制")]),_._v(" "),v("p",[_._v("不做赘述，选择合适的结构使代码清晰易读易于维护。")]),_._v(" "),v("ul",[v("li",[_._v("if else 与 switch case。")]),_._v(" "),v("li",[_._v("for、foreach、while、do while。")])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[_._v("#")]),_._v(" 函数")]),_._v(" "),v("ul",[v("li",[_._v("函数名是大小写无关的，使用小驼峰。")]),_._v(" "),v("li",[_._v("支持可变参数、默认参数。")]),_._v(" "),v("li",[_._v("支持可变函数的概念，这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它："),v("code",[_._v("$functionName()")]),_._v("。")]),_._v(" "),v("li",[_._v("匿名函数，通常作为回调。")])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[_._v("#")]),_._v(" 面向对象")]),_._v(" "),v("ul",[v("li",[_._v("封装")]),_._v(" "),v("li",[_._v("继承")]),_._v(" "),v("li",[_._v("多态：PHP 区别于传统的面向对象语言。")])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"类与对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类与对象"}},[_._v("#")]),_._v(" 类与对象")]),_._v(" "),v("ul",[v("li",[_._v("访问控制：public、protected、private。")]),_._v(" "),v("li",[_._v("属性：\n"),v("ul",[v("li",[_._v("静态属性：static。")]),_._v(" "),v("li",[_._v("非静态属性。")])])]),_._v(" "),v("li",[_._v("类常量 "),v("code",[_._v("constant")])]),_._v(" "),v("li",[_._v("构造函数 "),v("code",[_._v("__construct()")]),_._v("。\n"),v("ul",[v("li",[_._v("如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 "),v("code",[_._v("parent::__construct()")]),_._v("。")])])]),_._v(" "),v("li",[_._v("析构函数 "),v("code",[_._v("__destruct()")]),_._v("，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。")]),_._v(" "),v("li",[_._v("范围解析操作符（"),v("code",[_._v("::")]),_._v("）\n"),v("ul",[v("li",[_._v("静态成员、类常量的访问。")]),_._v(" "),v("li",[_._v("用于覆盖类中的属性和方法，当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于构造函数和析构函数，重载以及魔术方法。"),v("code",[_._v("parent::functionName()")]),_._v("。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"继承与重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#继承与重写"}},[_._v("#")]),_._v(" 继承与重写")]),_._v(" "),v("p",[_._v("对象的继承使用 "),v("code",[_._v("extends")]),_._v(" 关键字，会继承"),v("strong",[_._v("公有成员")]),_._v("、"),v("strong",[_._v("保护成员")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("方法名、参数列表必须完全一致。")]),_._v(" "),v("li",[_._v("子类的访问控制应该和父类相同或者比父类更加开放。")])]),_._v(" "),v("slide"),_._v(" "),v("h2",{attrs:{id:"重载与魔术方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重载与魔术方法"}},[_._v("#")]),_._v(" 重载与魔术方法")]),_._v(" "),v("p",[_._v("PHP 中的重载与其它绝大多数面向对象语言不同。传统的重载是用于提供多个同名的类方法，但各方法的参数类型和个数不同。\nPHP 所提供的重载是指动态地创建类属性和方法，通过魔术方法来实现。")]),_._v(" "),v("ul",[v("li",[_._v("所有的重载方法都必须被声明为 "),v("code",[_._v("public")]),_._v("。")]),_._v(" "),v("li",[_._v("当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。\n"),v("ul",[v("li",[_._v("未定义属性： "),v("code",[_._v("__get()")]),_._v("、"),v("code",[_._v("__set()")]),_._v("、"),v("code",[_._v("__isset()")]),_._v(" 和 "),v("code",[_._v("__unset()")]),_._v(" 进行属性重载。")]),_._v(" "),v("li",[_._v("未定义方法： "),v("code",[_._v("__call()")]),_._v(" 和 "),v("code",[_._v("__callStatic()")]),_._v("。")])])]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/language.oop5.magic.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("魔术方法"),v("OutboundLink")],1),_._v("。")])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"抽象类与接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#抽象类与接口"}},[_._v("#")]),_._v(" 抽象类与接口")]),_._v(" "),v("p",[_._v("抽象类通常是对与同一类事物所具有的特性进行的抽象，而接口则是对于事物所具备的能力的抽象。")]),_._v(" "),v("ul",[v("li",[_._v("使用：\n"),v("ul",[v("li",[_._v("抽象类使用 "),v("code",[_._v("abstract")]),_._v(" 关键字，包含抽象方法的类，不能实例化，子类必须实现该方法。")]),_._v(" "),v("li",[_._v("接口使用 "),v("code",[_._v("interface")]),_._v(" 关键字，实现接口使用 "),v("code",[_._v("implements")]),_._v("。")])])]),_._v(" "),v("li",[_._v("成员定义：\n"),v("ul",[v("li",[_._v("接口只能定义方法、常量。")]),_._v(" "),v("li",[_._v("抽象类可以定义变量、构造方法。")])])]),_._v(" "),v("li",[_._v("访问控制：\n"),v("ul",[v("li",[_._v("接口为 "),v("code",[_._v("public")]),_._v("。")]),_._v(" "),v("li",[_._v("抽象类可以用 "),v("code",[_._v("public")]),_._v("、"),v("code",[_._v("protected")]),_._v("、"),v("code",[_._v("private")]),_._v("。")])])]),_._v(" "),v("li",[_._v("继承：\n"),v("ul",[v("li",[_._v("接口可以多继承。")]),_._v(" "),v("li",[_._v("抽象类只能单继承。")])])])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"对象复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象复制"}},[_._v("#")]),_._v(" 对象复制")]),_._v(" "),v("p",[_._v("使用 "),v("code",[_._v("clone")]),_._v(" 关键字进行对象的复制。")]),_._v(" "),v("ul",[v("li",[_._v("因为对象的赋值和参数传递都是引用的，因此当不希望改变原对象时需要进行赋值。")]),_._v(" "),v("li",[_._v("当对象被复制后，会对对象的所有属性执行一个浅复制，所有的引用属性仍然会是一个指向原来的变量的引用。")]),_._v(" "),v("li",[v("code",[_._v("__clone()")]),_._v("：__clone 魔术方法会在对象被复制的时候被触发，可用于修改属性的值。")])]),_._v(" "),v("h3",{attrs:{id:"遍历对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#遍历对象"}},[_._v("#")]),_._v(" 遍历对象")]),_._v(" "),v("p",[_._v("可以使用 foreach 或者实现 "),v("a",{attrs:{href:"https://www.php.net/manual/zh/class.iterator.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("Iterator 接口"),v("OutboundLink")],1),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"对象序列化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象序列化"}},[_._v("#")]),_._v(" 对象序列化")]),_._v(" "),v("ul",[v("li",[_._v("所有 php 里面的值都可以使用函数 "),v("code",[_._v("serialize()")]),_._v(" 来返回一个包含字节流的字符串来表示。")]),_._v(" "),v("li",[v("code",[_._v("unserialize()")]),_._v(" 函数能够重新把字符串变回 php 原来的值。")]),_._v(" "),v("li",[_._v("序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。")]),_._v(" "),v("li",[_._v("为了能够 "),v("code",[_._v("unserialize()")]),_._v(" 一个对象，这个对象的类必须已经定义过。如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数 "),v("code",[_._v("spl_autoload_register()")]),_._v(" 来实现。")])]),_._v(" "),v("slide"),_._v(" "),v("h3",{attrs:{id:"对象与引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象与引用"}},[_._v("#")]),_._v(" 对象与引用")]),_._v(" "),v("ul",[v("li",[_._v("PHP 的引用是别名，并不是指针，是两个不同的变量名字保存同一个标识符的拷贝。")]),_._v(" "),v("li",[_._v("对象是引用传递的：\n"),v("ul",[v("li",[_._v("当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。")])])])]),_._v(" "),v("h2",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.php.net/manual/zh/langref.php",target:"_blank",rel:"noopener noreferrer"}},[_._v("PHP 手册"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/inetfuture/technote/tree/master/php#style-guide",target:"_blank",rel:"noopener noreferrer"}},[_._v("PHP style guide"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://php.golaravel.com/intro-whatis.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("PHP 中文手册"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/codeguy/modern-php",target:"_blank",rel:"noopener noreferrer"}},[_._v("Modern PHP"),v("OutboundLink")],1)])])],1)}),[],!1,null,null,null);v.default=l.exports}}]);